import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { getCss } from '../src/utils.js';

describe('getCss', () => {
    let createdStyleElements = [];

    beforeEach(() => {
        // Clean up any existing style elements
        document.head.querySelectorAll('style').forEach(el => el.remove());
        createdStyleElements = [];
    });

    afterEach(() => {
        // Clean up created style elements
        createdStyleElements.forEach(el => {
            if (el.parentNode) {
                el.parentNode.removeChild(el);
            }
        });
        createdStyleElements = [];
    });

    function createStyleElement(content) {
        const style = document.createElement('style');
        style.textContent = content;
        document.head.appendChild(style);
        createdStyleElements.push(style);
        return style;
    }

    describe('priority: tailwindcss.com comments', () => {
        it('should return CSS with tailwindcss.com in comment', () => {
            const cssContent = '/* from tailwindcss.com */ .test { color: red; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should match tailwindcss.com with various comment formats', () => {
            const cssContent = '/*! tailwindcss.com v3.0 */ .utility { display: flex; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should match tailwindcss.com in multiline comments', () => {
            const cssContent = `/*
             * Source: tailwindcss.com
             * Version: 3.0
             */
            .bg-blue { background: blue; }`;
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should prioritize tailwindcss.com over tailwindcss', () => {
            const genericTailwind = '/* tailwindcss */ .generic { color: blue; }';
            const officialTailwind = '/* from tailwindcss.com */ .official { color: red; }';
            
            createStyleElement(genericTailwind);
            createStyleElement(officialTailwind);

            const result = getCss();

            expect(result).toBe(officialTailwind);
        });

        it('should match tailwindcss.com with URL protocol', () => {
            const cssContent = '/* https://tailwindcss.com */ .test { margin: 0; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should be case-sensitive for tailwindcss.com', () => {
            const cssContent = '/* TailwindCSS.com */ .test { padding: 10px; }';
            createStyleElement(cssContent);

            const result = getCss();

            // The regex is case-sensitive, so this won't match
            expect(result).toBe('');
        });

        it('should match exact lowercase tailwindcss.com', () => {
            const cssContent = '/* tailwindcss.com */ .test { padding: 10px; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });
    });

    describe('fallback: tailwindcss comments', () => {
        it('should return CSS with tailwindcss in comment when .com version not found', () => {
            const cssContent = '/* tailwindcss */ .fallback { color: green; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should match tailwindcss with version info', () => {
            const cssContent = '/* tailwindcss v3.4.0 */ .version { font-size: 16px; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should match tailwindcss in longer comment', () => {
            const cssContent = '/* Generated by tailwindcss build process */ .generated {}';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should not match when only .com suffix present without tailwindcss', () => {
            const cssContent = '/* example.com */ .other { color: black; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe('');
        });
    });

    describe('multiple style elements', () => {
        it('should return first matching element when multiple have tailwindcss.com', () => {
            const first = '/* tailwindcss.com v1 */ .first {}';
            const second = '/* tailwindcss.com v2 */ .second {}';
            
            createStyleElement(first);
            createStyleElement(second);

            const result = getCss();

            expect(result).toBe(first);
        });

        it('should skip non-matching elements', () => {
            createStyleElement('/* bootstrap */ .bootstrap {}');
            createStyleElement('/* normalize */ .normalize {}');
            const tailwindCss = '/* tailwindcss */ .tailwind {}';
            createStyleElement(tailwindCss);

            const result = getCss();

            expect(result).toBe(tailwindCss);
        });

        it('should handle mix of tailwindcss and tailwindcss.com comments', () => {
            const generic = '/* tailwindcss */ .generic {}';
            const official = '/* tailwindcss.com */ .official {}';
            
            createStyleElement(generic);
            createStyleElement(official);

            const result = getCss();

            // Should prioritize .com version
            expect(result).toBe(official);
        });
    });

    describe('edge cases', () => {
        it('should return empty string when no style elements exist', () => {
            const result = getCss();

            expect(result).toBe('');
        });

        it('should return empty string when no matching comments found', () => {
            createStyleElement('/* bootstrap */ .btn {}');
            createStyleElement('/* custom styles */ .custom {}');

            const result = getCss();

            expect(result).toBe('');
        });

        it('should handle empty style elements', () => {
            createStyleElement('');
            const tailwindCss = '/* tailwindcss */ .test {}';
            createStyleElement(tailwindCss);

            const result = getCss();

            expect(result).toBe(tailwindCss);
        });

        it('should handle style element with only whitespace', () => {
            createStyleElement('   \n\t  ');
            const tailwindCss = '/* tailwindcss */ .test {}';
            createStyleElement(tailwindCss);

            const result = getCss();

            expect(result).toBe(tailwindCss);
        });

        it('should match tailwindcss at end of longer comment', () => {
            const cssContent = '/* This is generated by tailwindcss */ .test {}';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should match tailwindcss.com at start of comment', () => {
            const cssContent = '/* tailwindcss.com - utility framework */ .test {}';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should handle comments with special characters', () => {
            const cssContent = '/* @tailwindcss.com | v3.4.0 */ .test {}';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should not match tailwindcss outside of comments', () => {
            const cssContent = '.tailwindcss-utility { color: red; }';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe('');
        });

        it('should handle very large CSS content', () => {
            const largeCss = '/* tailwindcss */ ' + '.class {}'.repeat(1000);
            createStyleElement(largeCss);

            const result = getCss();

            expect(result).toBe(largeCss);
        });

        it('should match with newlines between comment markers and text', () => {
            const cssContent = `/*
            
            tailwindcss.com
            
            */
            .test {}`;
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should handle multiple comments in same style element', () => {
            const cssContent = `
                /* First comment */
                .class1 {}
                /* tailwindcss.com */
                .class2 {}
            `;
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });
    });

    describe('regex matching behavior', () => {
        it('should use dotall flag (match across newlines)', () => {
            const cssContent = `/* This is a 
            multiline comment with tailwindcss.com
            in the middle */ .test {}`;
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });

        it('should not match partial words', () => {
            createStyleElement('/* notailwindcss.com */ .test {}');
            createStyleElement('/* tailwindcss.coming */ .test2 {}');

            const result = getCss();

            // Should still match because regex doesn't check word boundaries
            expect(result).not.toBe('');
        });

        it('should match with extra spaces', () => {
            const cssContent = '/*   tailwindcss.com   */ .test {}';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });
    });

    describe('return value', () => {
        it('should return complete textContent including all CSS rules', () => {
            const cssContent = `/* tailwindcss */
            .class1 { color: red; }
            .class2 { color: blue; }
            .class3 { color: green; }`;
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
            expect(result).toContain('.class1');
            expect(result).toContain('.class2');
            expect(result).toContain('.class3');
        });

        it('should return exact textContent without modification', () => {
            const cssContent = '/* tailwindcss */\n\n.test {\n  color: red;\n}';
            createStyleElement(cssContent);

            const result = getCss();

            expect(result).toBe(cssContent);
        });
    });
});